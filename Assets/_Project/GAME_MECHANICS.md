# Описание механик игры Gravitarium

## Логика работы головоломок

Проект использует систему головоломок, основанную на абстрактном классе `BasePuzzle`. В игре реализовано три типа головоломок:

### 1. GravityPuzzle (Головоломка с позиционированием)

**Логика работы:**
- Игрок должен разместить определенные объекты в целевых позициях
- Каждый кадр система проверяет расстояние между объектами (`targetObjects`) и их целевыми позициями (`targetPositions`)
- Головоломка считается решенной, когда все объекты находятся в пределах `positionTolerance` от целевых позиций

**Механика:**
- Постоянная проверка прогресса в методе `CheckPuzzleProgress()`
- Визуальная обратная связь через смену материалов (correct/incorrect) на рендерерах объектов
- Прогресс рассчитывается как отношение правильно размещенных объектов к общему количеству

**Файлы:** `Puzzles/GravityPuzzle.cs`

---

### 2. KeyPuzzle (Головоломка с энергетическими ядрами)

**Логика работы:**
- Игрок должен собрать и разместить определенное количество `EnergyCore` в специальных слотах
- При сборе энергетического ядра через событие `EventBus.OnEnergyCoreCollected` оно автоматически размещается в следующем доступном слоте

**Механика:**
- Подписка на событие сбора ядер в методе `OnEnergyCoreCollected()`
- Автоматическое размещение ядра в слоте с правильной позицией и ротацией
- Опциональная поддержка размещения в определенном порядке (`requiresSpecificOrder`)
- Визуальная обратная связь через смену материалов слотов (empty/filled)

**Файлы:** `Puzzles/KeyPuzzle.cs`, `Items/EnergyCore.cs`

---

### 3. TerminalHackPuzzle (Головоломка с терминалом)

**Логика работы:**
- Игрок должен выровнять единицы во всех колонках на одной горизонтальной строке
- Каждая колонка содержит 8 значений (0 или 1), но видно только 4 значения одновременно
- В каждой колонке есть только одна единица

**Механика:**
- 4 колонки с циклическими списками значений
- Стрелки вверх/вниз сдвигают значения в колонке (циклический сдвиг массива)
- Проверка решения происходит каждый кадр - ищется строка, где во всех колонках на одной позиции стоит единица
- При инициализации генерируется случайная позиция единицы в каждой колонке
- Если головоломка сразу решена, первая колонка случайно сдвигается для усложнения

**Файлы:** `Puzzles/TerminalHackPuzzle.cs`, `UI/TerminalHackUI.cs`

---

### Управление головоломками

**PuzzleManager:**
- Отслеживает все головоломки в сцене через словарь `puzzleDictionary`
- Подсчитывает количество решенных головоломок
- Вычисляет общий прогресс прохождения
- Поддерживает регистрацию новых головоломок и сброс всех головоломок

**Состояния головоломок:**
- `InProgress` - головоломка в процессе решения
- `Solved` - головоломка решена
- `Failed` - головоломка провалена

**Система событий:**
- `EventBus.InvokePuzzleSolved()` - уведомление о решении головоломки
- `EventBus.InvokePuzzleProgressed()` - уведомление о прогрессе решения

**Файлы:** `Puzzles/BasePuzzle.cs`, `Puzzles/PuzzleManager.cs`, `Core/EventBus.cs`

---

## Механика переворота персонажа

### Компоненты системы

Система переворота состоит из двух основных компонентов:

1. **GravitySystem** (`Player/GravitySystem.cs`)
   - Управляет направлением гравитации для персонажа
   - Отключает стандартную гравитацию Unity (`rb.useGravity = false`)
   - Применяет кастомную гравитацию через `rb.AddForce()` в `FixedUpdate`
   - Переключает направление между `Vector3.down` и `Vector3.up`

2. **PlayerController** (`Player/PlayerController.cs`)
   - Обрабатывает ввод от игрока
   - Управляет визуальным переворотом персонажа
   - Синхронизирует состояние с системой гравитации

### Процесс переворота

#### Шаг 1: Ввод игрока
- Нажатие кнопки `FlipGravity` вызывает метод `OnFlipGravity()`
- Проверяется, что переворот не выполняется в данный момент (`!isFlippingGravity`)

#### Шаг 2: Изменение гравитации
- Вызывается `gravitySystem.FlipGravity()`
- Инвертируется флаг `isGravityFlipped`
- Меняется вектор `currentGravity` (down ↔ up)
- Спавнится визуальный эффект через `ObjectPoolManager` (эффект "GravityFlip")
- Отправляется событие `EventBus.InvokeGravityFlipped(newGravity)`

#### Шаг 3: Визуальный переворот
- `PlayerController` подписан на событие `OnGravityFlipped`
- Запускается корутина `SmoothGravityFlip()`:
  - Плавно поворачивает персонажа на 180° вокруг оси Z
  - Использует `Quaternion.Slerp` для плавной интерполяции
  - Применяет smoothstep интерполяцию: `t = t * t * (3f - 2f * t)`
  - Длительность переворота: `rotationAmount / gravityFlipRotationSpeed` (обычно 1 секунда при скорости 180°/с)
  - Во время переворота устанавливается флаг `isFlippingGravity = true`, что блокирует управление камерой

### Дополнительные особенности

**Проверка земли:**
- Направление луча проверки зависит от состояния гравитации
- Если гравитация перевернута: луч направлен вверх (`Vector3.up`)
- Если гравитация нормальная: луч направлен вниз (`Vector3.down`)

**Движение персонажа:**
- Движение работает независимо от направления гравитации
- Используются локальные оси персонажа (forward/right)
- Горизонтальная составляющая обнуляется для корректной работы на любой поверхности

**Физика:**
- `Rigidbody` имеет замороженное вращение по осям X и Y (`rb.freezeRotation = true`)
- Вращение применяется только через `rb.MoveRotation()` для плавности
- Используется интерполяция `RigidbodyInterpolation.Interpolate` для сглаживания движения

### Итог

Механика переворота позволяет персонажу:
- Мгновенно менять направление гравитации (физика)
- Плавно визуально переворачиваться (анимация)
- Ходить как по полу, так и по потолку
- Сохранять контроль над движением в любом направлении

**Файлы:** `Player/GravitySystem.cs`, `Player/PlayerController.cs`


